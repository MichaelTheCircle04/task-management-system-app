# task-management-system-app 

### Технологии:
- Spring Boot
- Spring Security
- Spring MVC
- Spring Data JPA
- Spring HATEOAS
- Spring Test
- Keycloak
- Docker + Docker-compose
- PostgreSQL + H2

### Цели:
- Дополнительно изучить взаимодействие приложений в контейнерах между собой
- Попрактиковаться в использовании Keycloak в качестве сервера авторизации
- Расширить практический опыт использования OAuth2 и тестирования приложений защищенных с помощью этого протокола

### Концепция:
Приложение представляет из себя систему управлениями задачами. В ней есть две основные логические единицы: задача и комментарий.
Система защищена с помощью протокола OAuth2, в качестве сервера авторизации используется Keycloak. Доступ к задаче может 
получить либо пользователь с ролью админ, либо пользователь являющийся автором, либо исполнителем этой задачи. Создать задачу может
только админ (стоит признать, что приложение в этом отношении несколько усложнено, ведь оно всегда проверяет является ли пользователь
автором либо исполнителем задачи, в то время как проверять является ли пользователь автором в данном случае не имеет смысла,
потому что если он админ, то он уже может получить доступ, а если не админ, то не может быть автором, впрочем, в силу того,
что это учебный проект, я предусмотрел только две роли, в то время как в реальном приложении ролей может быть значительно больше
и пользователь наделенный полномочиями создавать задачи вполне возможно может не иметь доступа к просмотру чужих задач и не являться админом).
Оставлять и получать комментарии к задаче может тот же круг пользователей что и получать доступ к самой задаче. При создании задачи 
пользователю необходимо указать: заголовок, описание и приоритет. Также можно опционально указать следующие параметры: статус (если не указан, устанавливается: "ЖДЕТ") и 
исполнителя (если не указан, устанавливается "ОЖИДАЕТСЯ"). Для создания комментария необходимо просто в теле запроса указать текст. 
В ответ на запросы система возвращает репрезентационною модель с рядом ссылок, для задачи это: на себя, на все задачи этого автора, на все задачи 
этого исполнителя (если установлен), на комментарии и на удаление; для комментария: на себя и на все комментарии этого автора. Также, при запросе, 
ответом на который должно быть множество комменатриев, ответ представляет собой экземпляр класса PagedModel со ссылкой на задачу, к которой оставлены
комменатрии.

### Заметки:
Для удаления задач я решил вместо выставления свойства orphanRemoval = true/CascadeType в REMOVE и вызова метода deleteById TaskRepository(extends JpaRepository), 
разделить это действие на два этапа: вызвать метод deleteByTaskId (написанный вручную) TaskCommentRepository, а потом deleteById TaskRepository.
Необходимо это для того, чтобы избежать лишние запросы, потому что иначе Hibernate сначала делает SELECT задачи, потом SELECT комментариев (потому что
FetchType установлен LAZY), затем по одному DELETE'у на каждый комментарий и еще один на задачу. Следовательно получается такая ситуция при которой 
для удаление задачи которую можно удалить в 2 запроса вызывается 3 + n (где n равно колличеству комментариев) запросов. 

### Компоненты:
- ***Assembler - ассемблеры для превращения сущностей Task и TaskComment в EntityModel и объектов Page в PagedModel
- SecurityConfig - конфигурация с настройками безопасности приложения
- SystemController - основной контролер куда приходят запросы 
- SystemControllerAdvice - exceptionHandler для SystemController
- Task, TaskComment - сущности описывающи записи в базе данных
- ***Repository - JPA репозитории для доступа к сущностям Task и TaskComment
- TaskService - сервис для работы с объектами Task и TaskComment
- @WithCustomUser - аннотация для настройки контекста безопасности в тестах
- CustomSecurityContextFactory - класс для обработки анноатции @WithCustomUser и создании контекста безопасности
на основании данных из аннотации 
- SystemControllerTest - интеграционный тест состоящий из 45 аннотированных @Test методов 
для проверки основной функциональности контроллера SystemController, в основном методы однотипные, 
я старался покрыть побольше сценариев, но тем не менее для покрытия ВСЕХ сценариев необходимо написать 
слишком много тестов, чего я делать не стал

### Запуск:
Приложение запускается просто с помощью комманды docker-compose up. Помимо контейера с приложением 
сразу поднимаются контейнеры с базой PostgreSQL и некоторым набором данных и контейнер с Keycloak в котором сразу 
инициализируется прежде настроенный realm
